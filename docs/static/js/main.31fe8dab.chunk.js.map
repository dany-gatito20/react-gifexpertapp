{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategorias","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","key","GifExpertApp","categorias","ReactDOM","render","document","getElementById"],"mappings":"yMAMaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAERC,mBAAS,IAFD,mBAErCC,EAFqC,KAEzBC,EAFyB,KAkB5C,OACI,0BAAMC,SAVW,SAACC,GAClBA,EAAEC,iBAEGJ,EAAWK,OAAOC,OAAS,IAC5BR,GAAgB,SAAAS,GAAI,OAAMP,GAAN,mBAAqBO,OACzCN,EAAc,OAKlB,IACI,2BACIO,KAAK,OACLC,MAAQT,EACRU,SAlBc,SAACP,GACvBF,EAAeE,EAAEQ,OAAOF,Y,uBCTnBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAGbC,EAHa,iDAGoCC,UAAWH,GAH/C,+DAIAI,MAAOF,GAJP,cAIbG,EAJa,gBAKIA,EAAKC,OALT,uBAKXC,EALW,EAKXA,KAEFC,EAAOD,EAAKE,KAAK,SAAAC,GACnB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAKQ,EAAIG,OAAOC,iBAAiBZ,QAXtB,kBAeZM,GAfY,4CAAH,sDCCPO,EAAc,SAAC,GAAoB,IAAlBH,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAEjC,OACI,yBAAKc,UAAU,8CACX,yBAAKC,IAAMf,EAAMgB,IAAMN,IAD3B,IAEI,+BAAMA,EAAN,KAFJ,MCCKO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAETa,ECJW,SAAEb,GAAe,IAAD,EAEdd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KAoBxC,OAbAC,qBAAY,WAERxB,EAASC,GACJwB,MAAM,SAAAC,GAEHH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAItB,CAACpB,IAEGqB,EDhBiBK,CAAc1B,GAA9BO,KAOR,OACI,oCACI,wBAAIS,UAAU,yCAAd,IAAyDhB,EAAzD,KAIA,yBAAKgB,UAAU,aAGPH,EAAOJ,KAAK,SAAAC,GAAG,OACX,kBAAC,EAAD,eACIiB,IAAMjB,EAAIC,IACLD,UEvBpBkB,EAAe,WAAM,MAGM1C,mBAAS,CAAC,cAHhB,mBAGvB2C,EAHuB,KAGX5C,EAHW,KAU9B,OACI,oCACI,4CADJ,IAEI,kBAAC,EAAD,CAAaA,cAAgBA,IAFjC,IAGI,6BAHJ,KAOI,4BAEQ4C,EAAWpB,KAAK,SAAAT,GAAQ,OACpB,kBAAC,EAAD,CACI2B,IAAM3B,EACNA,SAAWA,U,MCtBvC8B,IAASC,OACL,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.31fe8dab.chunk.js","sourcesContent":["\r\n// Componente que se encarge de crear una Caja de Texto\r\n\r\nimport React, { useState } from 'react';\r\nimport PropTypes from 'prop-types'; // importamos el PropTypes\r\n\r\nexport const AddCategory = ({setCategorias}) => { // aqui se destructuran los componentes y solo quiero llamar a setCategorias\r\n\r\n    const [inputValue, setInputValue] = useState('');\r\n    // el setInputValue es el que va a cambiar la caja de texto y el inputValue tiene por defecto un valor de un String, un Arreglo, un objeto, etc, aqui tiene un valor de un string de espacio vacio ('')\r\n\r\n    const handleInputChange = (e) => { // constante que se lamara handleInputChange para extraer el valor del evento (e) en el onChange\r\n        setInputValue( e.target.value ); // llamamos el setInputValue se coloco e.target.value, es la impresion del evento, las veces que sean\r\n    }\r\n\r\n    const handleSubmit = (e) => { // con la constante handleSumit lo que hace es que al escribir una palabra adentro de la caja de texto y hacer click, nos dispare algo en la pagina o busca algo\r\n        e.preventDefault();  // esto es para prevenir el comportamiento por defecto de formulario y manejarlo\r\n\r\n        if ( inputValue.trim().length > 2 ) { // Validacion: si esto es mayor a 2 letras, se llamara la siguiente instruccion\r\n            setCategorias ( cats => [ inputValue, ...cats ] );  // llamamos aqui a setCategorias, para que al hacer Enter llame a setCategorias y dispare algo / cats = categorias que se van ir agregando en la caja de texto al preonar Enter\r\n            setInputValue(''); // setInputValue lo mandamos como un string vacio ('')\r\n        }\r\n    }\r\n\r\n    return(\r\n        <form onSubmit={ handleSubmit }> {/* con el onSubmit lo que hace es evitar un refresh completo de la pagina. Ademas colocamos el handleSubmit que contiene el evento de dar click a lo que escribiste dentro de la caja de texto */}\r\n            <input           // con el input se crea una caja de texto para que pueda escribir y buscar \r\n                type=\"text\"  // Type es el tipo de valor que debe ser, aqui dice que debe de ser un valor de texto\r\n                value={ inputValue }  // aqui se le puso el valor de inputValue, lo cual aparecera la caja de texto sin nada, por el valor del espacio vacio ( Checa Arriba )\r\n                onChange={ handleInputChange } // el onChange se va a disparar cuando la caja de texto cambie, con esto puedes escribir adentro de la caja de texto lo que quieras sin afectar lo demas\r\n            />\r\n        </form>\r\n    )\r\n};\r\n\r\nAddCategory.propTypes = {   // aqui con el PropTypes estamos diciendo que setCategorias esta marcada como requerida, sino seria un error\r\n    setCategorias: PropTypes.func.isRequired // funcion requerida para este componente\r\n};","\r\n// Necesito recibir la categoria y luego una peticion http.\r\n\r\nexport const getGifs = async( category ) => {\r\n            // aqui colocamos category adentro de url, para que cuando coloques alguna palabra y des enter, \r\n            //de respuesta te regrese imagenes con el mismo titulo de tu palabra que buscastes. se aÃ±ade con signo $ y el llaves colocas encodeURI y tu elemnto\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=cgQah45u7ompStZbqXq4dzKZw4q9G960`\r\n    const resp = await fetch( url );   // constante llamada respuesta del url, si se hizo correctamente\r\n    const { data } = await resp.json();\r\n\r\n    const gifs = data.map( img =>{ // Extraer la inofrmacion de las imagenes, img va a barrer cada una de esas imagenes \r\n        return { // este return va a transformar cada uno de los elementos que estan dentro del arreglo de img y va a retornar un nuevo objeto con la informacion que me interesa\r\n            id: img.id, // en este caso me interesa el id de la imagen\r\n            title: img.title, // me interesa el title ( titulo ) de la imagen, lo saco de img y ahi tomo el title\r\n            url: img.images.downsized_medium.url // me interesa el url de la imagen, lo saco de img, lo tomo de images, lo saco de downsized_medium y de ahi tomo el url\r\n        }\r\n    })\r\n\r\n    return gifs; // regresar los gifs\r\n}","// Componente que va a tener mas elemntos, va a mostrar la imagen o otras cosas\r\n\r\nimport React from 'react';\r\n\r\nexport const GifGridItem = ({ title, url }) => { // GifGridItem es un nuevo componente que se pondra en el archivo de GifGrid.js \r\n                            // aqui se toma solo el titulo y el url de las imagenes\r\n    return ( // aqui regresamos la imagen pero ya impresa en el html de la pagina con su titulo\r\n        <div className=\"card animate__animated animate__backInDown\">\r\n            <img src={ url } alt={ title } /> {/* colocamos la imagen */}\r\n            <p> { title } </p> {/* colocamos el valor del titulo ( title ) dentro de un p ( parrafo ) */}\r\n        </div>\r\n    )\r\n};\r\n\r\n// NOTA: className es como se nombra a una clase normal para el html,\r\n// pero aqui se confunde con las clases de Javascript,\r\n// por ello se nombra className a una clase para html","// Componente que recibe el arreglo ('One Punch') como argumento\r\n// y la cual se va a disparar la peticion http.\r\n\r\nimport React from 'react'; // useEffect me permite ejecutar cierto codigo de manera condicional y evita hacer ese codigo un ciclo infinito\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n//import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({ category }) => { // constante llamada GifGrid la cual llama a Category\r\n\r\n    const { data:images } = useFetchGifs( category );\r\n    //const [images, setImages] = useState([]); // nuevo estado llamado images\r\n    //useEffect( () => { // solo quiero que el componente se renderize una sola vez\r\n    //    getGifs( category ) // esto retorma una promesa\r\n    //        .then( setImages ); //regresamos el setImages\r\n    //}, [ category ]) // arreglo de dependencias / aqui dice que si la categoria cambia, entonces volvera a ejecutar esta funcion\r\n\r\n    return (  // que regrese el nombre de la categoria que escribiste, con la imagen y su titulo\r\n        <>\r\n            <h3 className=\"animate__animated animate__backInDown\"> { category } </h3>\r\n\r\n            {/* loading && <p className=\"animate__animated animate__flash\">Loading</p> */}\r\n\r\n            <div className=\"card-grid\">\r\n\r\n                {\r\n                    images.map( img => ( // aqui ya solo amandamos img  \r\n                        <GifGridItem     // aqui colocamos componente de \"GifGridItem\" del archivo de GifGridItem.js\r\n                            key={ img.id } // key que es igual a img, el cual tomamos solo el id\r\n                            { ...img }\r\n                        />\r\n                    ))\r\n                }\r\n\r\n            </div>\r\n        </>\r\n    )\r\n}","// Los Custom Hooks funcionan como si fueran Functional Components,\r\n// pueden tener efectos, reducer, contextos, etc.\r\n\r\nimport { useEffect, useState } from \"react\"\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    useEffect ( () => {\r\n\r\n        getGifs( category )\r\n            .then( imgs => {\r\n\r\n                setState({\r\n                    data: imgs,\r\n                    loading: false\r\n                });\r\n            })\r\n\r\n    }, [category])\r\n\r\n    return state; // { data:[], loading: true };\r\n}","// Componente llamado GifExpertApp\r\n\r\nimport React, { useState } from 'react'; // importamos useState que esta dentro del paquete de React\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    //const categorias = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n    const [categorias, setCategorias] = useState(['One Punch']);  // aqui tenia un listado, pero solo aparece uno en la pantalla principal\r\n\r\n    //const handleAdd = () => ( // agregar un nuevo elemnto al arreglo\r\n        //setCategorias( ['Hunter X Hunter', ...categorias] )  // Primera forma de agregar un nuevo elemento con el boton de Agregar\r\n    //    setCategorias( cats => [...cats, 'Hunter X Hunter'] )  // Segunda forma de agregar un nuevo elemento con el boton de Agregar\r\n    //);\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2> {/* Titulo */}\r\n            <AddCategory setCategorias={ setCategorias } /> {/* Comunicacion entre componentes, aqui la llamamos con la referencia de setCategorias para que enteractuen entre si */}\r\n            <hr />\r\n\r\n            {/*<button onClick={ handleAdd }>Agregar</button>*/}  {/* Boton de click para Agregar nuevo elemento */}\r\n\r\n            <ol>\r\n                {\r\n                    categorias.map( category => (  // el .map me sirve para transformar cada uno de los elemntos que estan dentro de su arreglo. Recibe 2 argunatos por defecto, 1.- el elemento del arreglo ( Category ), 2.- el indice\r\n                        <GifGrid    // traemos GifGrid exportandola \r\n                            key={ category }  // el key sirve para que React sepa cual es el elemento que esta literado\r\n                            category={ category } // category es igual a category que estor evaluando ( category de letras naranjas )\r\n                        />\r\n                    ))\r\n                }\r\n            </ol>\r\n        </>\r\n    )\r\n};","\nimport React from 'react';\nimport ReactDOM from 'react-dom'; // Traer el archivo de ReactDom\nimport { GifExpertApp } from './GifExpertApp'; // importar el componente de GitExpertApp\n\nimport './index.css'   // importacion de mi hoja de estilos a mi proyecto\n\nReactDOM.render(\n    <GifExpertApp />,\n    document.getElementById('root') // linea para renderizar la aplicacion de React\n);\n\n\n// GifExpertApp\n// "],"sourceRoot":""}